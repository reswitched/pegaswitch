/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
var sploitcore = require('./sploitcore');
var sploitMixin = require('./sploitMixin');
var svcMixin = require('./svc');
var utils = require('./utils');
var ResultCode = require('./ResultCode');
var Result = require('./Result');

function IPCMessage (sc, sender, cmdId) {
    this.sc = sc;
    this.sender = sender;
    this.pid = null;
    this.type = 4;
    this.cmdId = cmdId;
    this.resultCode = cmdId;
    this.success = this.resultCode === 0 || this.resultCode === undefined;
    this.dataBuffer = [];
    this.aDescriptors = [];
    this.bDescriptors = [];
    this.cDescriptors = [];
    this.xDescriptors = [];
    this.copiedHandles = [];
    this.movedHandles = [];
    this.objectDomainCommand = undefined;
    this.objectId = 0;
    this.inputObjectIds = [];
    this.copyBuffers = [];
}

IPCMessage.prototype.setType = function (t) {
    this.type = t;
    return this;
};

IPCMessage.prototype.sendPid = function () {
    this.pid = true;
    return this;
};

IPCMessage.prototype.setCmd = function (cmdId) {
    this.cmdId = cmdId;
    this.resultCode = cmdId;
    return this;
};

IPCMessage.prototype.setResult = function (rescode) {
    this.setCmd(rescode);
    this.success = this.resultCode === 0;
};

IPCMessage.prototype.data = function () {
    this.dataBuffer = [];
    for (var i = 0; i < arguments.length; i++) {
        var v = arguments[i];
        if (v instanceof Array) {
            this.dataBuffer.push(v[0]);
            this.dataBuffer.push(v[1]);
        } else if(typeof(v) === "number") {
            this.dataBuffer.push(v);
            this.dataBuffer.push(0);
        } else {
            throw new Error("can't put in an IPC request: " + v);
        }
    }

    return this;
};

IPCMessage.prototype.datau32 = function () {
    this.dataBuffer = [];
    for (var i = 0; i < arguments.length; i++) {
        this.dataBuffer.push(utils.trunc32(arguments[i]));
    }
    return this;
};

IPCMessage.prototype.datau64 = function () {
    this.dataBuffer = [];
    for (var i = 0; i < arguments.length; i++) {
        var v = utils.pad64(arguments[i]);
        this.dataBuffer.push(v[0]);
        this.dataBuffer.push(v[1]);
    }

    return this;
};

IPCMessage.prototype.dataArrayBuffer = function(ab) {
    this.dataBuffer = [];
    var u32 = new Uint32Array(ab);
    for(var i = 0; i < u32.length; i++) {
        this.dataBuffer[i] = u32[i];
    }

    return this;
};

IPCMessage.prototype.addDescriptor = function (da, addr, size, third) {
    if (addr instanceof ArrayBuffer || ArrayBuffer.isView(addr)) {
        var buf = addr;
        if (size === undefined) {
            size = buf.byteLength;
        }
        if (this.sender.isBrowser) {
            if (buf.addr === undefined) {
                buf.addr = this.sc.getArrayBufferAddr(buf);
            }
            addr = buf.addr;
        } else {
            addr = this.sender.malloc(size);
            this.copyBuffers.push({
                addr, buf, size
            });
        }
    }
    addr = utils.pad64(addr);
    size = utils.pad64(size);
    if (third !== undefined) { da.push([addr, size, third]); } else { da.push([addr, size]); }
    return this;
};

IPCMessage.prototype.aDescriptor = function (addr, size, perm) {
    return this.addDescriptor(this.aDescriptors, addr, size, perm);
};

IPCMessage.prototype.bDescriptor = function (addr, size, perm) {
    return this.addDescriptor(this.bDescriptors, addr, size, perm);
};

/*
    type 0xA buffers have u16 length shenanigans
 */
IPCMessage.prototype.cDescriptor = function (addr, size, hasU16Length) {
    return this.addDescriptor(this.cDescriptors, addr, size, hasU16Length);
};

IPCMessage.prototype.xDescriptor = function (addr, size, counter) {
    return this.addDescriptor(this.xDescriptors, addr, size, counter);
};

IPCMessage.prototype.copyHandle = function (handle) {
    this.copiedHandles.push(utils.trunc32(handle));
    return this;
};

IPCMessage.prototype.moveHandle = function (handle) {
    this.movedHandles.push(utils.trunc32(handle));
    return this;
};

IPCMessage.prototype.inputObjectId = function (id) {
    this.inputObjectId.push(utils.trunc32(id));
    return this;
};

IPCMessage.prototype.toObject = function (object) {
    this.objectDomainCommand = 1;
    this.objectId = object;
    return this;
};

IPCMessage.prototype.closeObject = function (object) {
    this.objectDomainCommand = 2;
    this.objectId = object;
    return this;
};

IPCMessage.prototype.pack = function () {
    /*
    Structure of an IPC packet:
    2*u32 header
      type
      number of descriptors
      length of raw data section / 4
      "flags for buf c descriptors"
      enable handle descriptor
    x descriptors
    a descriptors
    b descriptors
    w descriptors
    raw data section
      padding
      aligned data section
      padding
      c descriptor lengths
    c descriptors
   */
    var alignedDataSection = [];
  
    var dataPayload = [];
    dataPayload.push(0x49434653);
    dataPayload.push(0);
    dataPayload.push(this.cmdId);
    dataPayload.push(0);
    for (var i = 0; i < this.dataBuffer.length; ++i) {
        dataPayload.push(this.dataBuffer[i]);
    }
  
    if (this.objectDomainCommand !== undefined) {
        alignedDataSection.push(this.objectDomainCommand | ((dataPayload.length * 4) << 16));
        alignedDataSection.push(this.objectId);
        alignedDataSection.push(0);
        alignedDataSection.push(0);
    }

    alignedDataSection = alignedDataSection.concat(dataPayload);

    var cDescriptorSection = [];
    for (var i = 0; i < this.cDescriptors.length; ++i) {
        var v = this.cDescriptors[i];
        var addr = utils.trunclt64(v[0], 48);
        var size = utils.trunclt32(v[1], 16);
        cDescriptorSection.push(addr[0]);
        cDescriptorSection.push((addr[1] & 0xFFFF) | (size << 16));
    }

    var cDescriptorsWithU16Length = this.cDescriptors.filter((c) => c[2]);
    var u16Lengths = cDescriptorsWithU16Length.map((c) => c[1][0]);
    if(u16Lengths.length % 2 > 0) {
        u16Lengths.push(0);
    }
    var cDescriptorLengthsSection = Array.from(new Uint32Array(new Uint16Array(u16Lengths).buffer));
  
    var descriptorSection = [];

    // handle descriptor
    if (this.pid || this.movedHandles.length > 0 || this.copiedHandles.length > 0) {
        descriptorSection.push((this.pid ? 1 : 0) | (this.copiedHandles.length << 1) | (this.movedHandles.length << 5)); // Handle descriptor
        if (this.pid) {
            descriptorSection.push(0);
            descriptorSection.push(0);
        }
        for (var i = 0; i < this.copiedHandles.length; ++i) { descriptorSection.push(this.copiedHandles[i]); }
        for (var i = 0; i < this.movedHandles.length; ++i) { descriptorSection.push(this.movedHandles[i]); }
    }

    // x descriptors
    for (var i = 0; i < this.xDescriptors.length; ++i) {
        var v = this.xDescriptors[i];
        var addr = v[0];
        var size = utils.trunc32(v[1]);
        var counter = v[2];
        descriptorSection.push(
            (counter & 0x3F) |
            (((addr[1] & 0x70) >>> 4) << 6) |
            (counter & 0xE00) |
            ((addr[1] & 0xF) << 12) |
            size << 16
        );
        descriptorSection.push(addr[0]);
    }

    // a & b descriptors
    for (var i = 0; i < this.aDescriptors.length + this.bDescriptors.length; ++i) {
        var v = i < this.aDescriptors.length ? this.aDescriptors[i] : this.bDescriptors[i - this.aDescriptors.length];
        var addr = v[0];
        var size = utils.pad64(v[1]);
        var perm = v[2];
        descriptorSection.push(size[0]);
        descriptorSection.push(addr[0]);
        descriptorSection.push(
            perm |
            (((addr[1] & 0x70) >>> 4) << 2) |
            ((size[1] & 0xF) << 24) |
            ((addr[1] & 0xF) << 28)
        );
    }

    var rawDataSection = [];
    var rawDataOffset = 2 + descriptorSection.length; // 2 header bytes + descriptors
    while (((rawDataSection.length + rawDataOffset) & 3) !== 0) { rawDataSection.push(0); } // padding
    var paddingLength = rawDataSection.length;
    rawDataSection = rawDataSection.concat(alignedDataSection);
    for (var i = 0; i < 4-paddingLength; ++i) { rawDataSection.push(0); } // 0x10 bytes total padding
    rawDataSection = rawDataSection.concat(cDescriptorLengthsSection);

    var headerSection = [];
    headerSection.push(
        this.type | // Request
        (this.xDescriptors.length << 16) |
        (this.aDescriptors.length << 20) |
        (this.bDescriptors.length << 24) |
        (0 << 28) // W descriptors count
    );
    headerSection.push(
        (rawDataSection.length) |
        ((this.cDescriptors.length !== 0 ? this.cDescriptors.length + 2 : 0) << 10) |
        (((this.pid || this.movedHandles.length > 0 || this.copiedHandles.length > 0) ? 1 : 0) << 31)
    );

    var buf = headerSection.concat(descriptorSection);
    buf = buf.concat(rawDataSection);
    buf = buf.concat(cDescriptorSection);
  
    for (var i = 0; i < buf.length; ++i) { buf[i] = buf[i] >>> 0; }

    return buf;
};

IPCMessage.prototype.sendTo = function (handleName) {
    var handle = handleName;
    if (!(handleName instanceof Array) && typeof(handleName) !== "number") {
        handle = this.sender.getAutoHandle(handleName);
    }

    if (this.packed === undefined) {
        this.packed = this.pack();
    }
    this.sc.ipcBuf.set(this.sc.emptyIpcBuf);
    this.sc.ipcBuf.set(this.packed);

    var self = this;

    if (this.sc !== this.sender) {
        this.sender.memcpyFromBrowser(this.sender.ipcBufAddr, this.sc.ipcBufAddr, 0x2000);
        this.copyBuffers.forEach((cr) => {
            self.sender.memcpyFromBrowser(cr.addr, cr.buf, cr.size);
        });
    }

    var ret = this.sender.svcSendSyncRequestWithUserBuffer(this.sender.ipcBufAddr, 0x2000, handle);

    if(!ret.isOk) {
        if (handle !== handleName) { // Remote port dead -- our handle is bad now
            this.sender.killAutoHandle(handleName);
        }
    }

    if (this.sc !== this.sender) {
        this.sender.memcpyToBrowser(this.sc.ipcBufAddr, this.sender.ipcBufAddr, 0x2000);
        this.copyBuffers.forEach((cr) => {
            self.sender.memcpyToBrowser(cr.buf, cr.addr, cr.size);
        });
    }

    if(ret.isOk) {
        return new IPCMessage(this.sc, this.sender).unpack(this.sc.ipcBuf, this.objectDomainCommand != null);
    } else {
        return new IPCFailure(this.sc, this.sender, ret.getError());
    }
};

IPCMessage.prototype.asyncSendTo = function (handleName, timeout) {
    if (this.sc !== this.sender) {
        throw new Error('asyncSendTo is only supported on sploitcore');
    }

    var handle = handleName;
    if (!(handle instanceof Array) && typeof(handle) !== "number") {
        // using auto handles with this asynchronous stuff would be a recipe for disaster
        handle = this.sc.getService(handleName);
    }

    if (this.packed === undefined) {
        this.packed = this.pack();
    }

    var ipcBuf = new Uint32Array(0x2000 >> 2);
    ipcBuf.set(this.packed);

    var self = this;
  
    return this.sc.asyncCaller.call(this.sc.gadget([0x41, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6]), [this.sc.getArrayBufferAddr(ipcBuf), 0x2000, handle], timeout).then((ret) => {
        if (ret[0] === 0xf601 && handle !== handleName) {
            self.sc.svcCloseHandle(handle);
        }
        if (ret[0] !== 0) {
            return new IPCFailure(self.sc, self.sender, new ResultCode(ret));
        } else {
            return new IPCMessage(self.sc, self.sender).unpack(ipcBuf, this.objectDomainCommand != null);
        }
    });
};

IPCMessage.prototype.unpack = function (buf, toDomain) {
    this.buffer = buf;
    if(toDomain === undefined) { toDomain = false; }
  
    this.dataBuffer = this.data = [];
    this.aDescriptors = [];
    this.bDescriptors = [];
    this.cDescriptors = [];
    this.xDescriptors = [];
    this.copiedHandles = [];
    this.movedHandles = [];

    var xCount = (buf[0] >>> 16) & 0xF;
    var aCount = (buf[0] >>> 20) & 0xF;
    var bCount = (buf[0] >>> 24) & 0xF;
    var wCount = (buf[0] >>> 28);

    if (wCount > 0) {
        throw new Error("can't unpack W descriptors yet");
    }

    var rawDataSectionLength = (buf[1] & 0x3FF) * 4;
    var alignedDataSectionLength = rawDataSectionLength - 0x10;
    var cDescriptors = ((buf[1] >>> 10) & 0x3) - 1;
    var hasHandleDescriptor = (buf[1] >>> 31) === 1;

    var pos = 2;

    if (hasHandleDescriptor) {
        var hd = buf[pos++];
        var hasPid = !!(hd & 1);
        var copyCount = (hd >>> 1) & 0xF;
        var moveCount = hd >>> 5;
        if (hasPid) { this.pid = [buf[pos++], buf[pos++]]; }
        for (var i = 0; i < copyCount; ++i) { this.copiedHandles.push(buf[pos++]); }
        for (var i = 0; i < moveCount; ++i) { this.movedHandles.push(buf[pos++]); }
    }

    for (var i = 0; i < xCount; ++i) {
        var a = buf[pos++];
        var b = buf[pos++];
        var addr = [b, (((a >>> 12) & 0xF) | ((a >>> 2) & 0x70)) >>> 0];
        var size = [a >>> 16, 0];
        var counter = (a & 0xE3F) >>> 0;
        this.xDescriptors.push([addr, size, counter]);
    }

    for (var i = 0; i < aCount + bCount; ++i) {
        var a = buf[pos++];
        var b = buf[pos++];
        var c = buf[pos++];
        var addr = [b, ((((c >>> 2) << 4) & 0x70) | ((c >>> 28) & 0xF)) >>> 0];
        var size = [a, ((c >>> 24) & 0xF) >>> 0];
        var perm = c & 3;
        if (i < aCount) { this.aDescriptors.push([addr, size, perm]); } else { this.bDescriptors.push([addr, size, perm]); }
    }

    var rawDataSectionOffset = pos;
    // padding
    if ((pos & 3) !== 0) { pos += 4 - (pos & 3); }

    var dataPayloadLength = alignedDataSectionLength;
    if (toDomain) {

        this.objectDomainCommand = buf[pos] & 0xFF;

        if(this.objectDomainCommand === 2) {
            dataPayloadLength = 0;
        }

        var dataLength = (buf[pos++] >> 16) + 0x10;
        var inputObjectIdCount = (dataPayloadLength - dataLength - 0x10) / 4;
        dataPayloadLength = dataLength;

        this.objectId = buf[pos++];
        pos+= 2;
    }

    this.packed = Array.from(buf);
  
    if(dataPayloadLength > 0) {
        var dataPayloadBegin = pos;
    
        if ((buf[pos] & 0x00FFFFFF) !== 0x434653) {
            utils.hexdump("bad msg", buf, 0x50);
            throw new Error("SFCI/SFCO wasn't in expected position");
        }
    
        pos += 2;
        this.cmdId = this.resultCode = buf[pos];
        this.success = this.cmdId === 0;
        pos+= 2;
    
        while (pos < dataPayloadBegin + (dataPayloadLength >> 2)) {
            this.data.push(buf[pos++]);
        }
    }

    if (toDomain) {
        while (inputObjectIdCount > 0) {
            // TODO: the u32 are technically unaligned.
            this.inputObjectIds.push(buf[pos++]);
            inputObjectIdCount -= 1;
        }
    }

    pos = rawDataSectionOffset + (rawDataSectionLength >> 2);
  
    for(var i = 0; i < cDescriptors; i++) {
        var a = buf[pos++];
        var b = buf[pos++];
        var addr = [a, (b & 0xFFFF) >>> 0];
        var size = [b >>> 16, 0];
        this.cDescriptors.push([addr, size]);
    }
  
    return this;
};

IPCMessage.prototype.show = function () {
    utils.log('IPC message:');
    if (this.resultCode !== 0) { utils.log('- Command ID / Result code: ' + new ResultCode(this.resultCode).toString()); }
    if (this.pid !== null) { utils.log('- PID: ' + utils.paddr(this.pid)); }
    if (this.dataBuffer.length > 0) {
        utils.log('- Data');
        utils.hexdump("    data", new Uint32Array(this.dataBuffer));
    }
    if (this.copiedHandles.length > 0) {
        utils.log('- Copied handles');
        for (var i = 0; i < this.copiedHandles.length; ++i) { utils.log('    - 0x' + this.copiedHandles[i].toString(16)); }
    }
    if (this.movedHandles.length > 0) {
        utils.log('- Moved handles');
        for (var i = 0; i < this.movedHandles.length; ++i) { utils.log('    - 0x' + this.movedHandles[i].toString(16)); }
    }
    if (this.inputObjectIds.length > 0) {
        utils.log('- Input Objects');
        for (var i = 0; i < this.inputObjectIds.length; ++i) { utils.log('    - 0x' + this.inputObjectIds[i].toString(16)); }
    }
    if (this.aDescriptors.length > 0) { utils.log('- ' + this.aDescriptors.length + ' A descriptor' + (this.aDescriptors.length > 1 ? 's' : '')); }
    if (this.bDescriptors.length > 0) { utils.log('- ' + this.bDescriptors.length + ' B descriptor' + (this.bDescriptors.length > 1 ? 's' : '')); }
    if (this.cDescriptors.length > 0) { utils.log('- ' + this.cDescriptors.length + ' C descriptor' + (this.cDescriptors.length > 1 ? 's' : '')); }
    if (this.xDescriptors.length > 0) { utils.log('- ' + this.xDescriptors.length + ' X descriptor' + (this.xDescriptors.length > 1 ? 's' : '')); }

    return this;
};

IPCMessage.prototype.showPacked = function () {
    utils.hexdump("ipcm", this.pack());
    return this;
};

IPCMessage.prototype.toBuilderString = function () {
    function fmtU32Array(arr) {
        return arr.map((u32) => "0x" + u32.toString(16)).join(", ");
    }
  
    var str = "sc.ipcMsg(" + this.cmdId + ")";
    if(this.type !== 4) { str+= ".setType(" + this.type + ")"; }
    if(this.dataBuffer.length > 0) { str+= ".data(" + fmtU32Array(this.dataBuffer) + ")"; }
    this.aDescriptors.forEach((ad) => {
        str+= ".aDescriptor(" + fmtU32Array(ad) + ")";
    });
    this.bDescriptors.forEach((ad) => {
        str+= ".bDescriptor(" + fmtU32Array(ad) + ")";
    });
    this.cDescriptors.forEach((ad) => {
        str+= ".cDescriptor(" + fmtU32Array(ad) + ")";
    });
    this.xDescriptors.forEach((ad) => {
        str+= ".xDescriptor(" + fmtU32Array(ad) + ")";
    });
    this.copiedHandles.forEach((ch) => {
        str+= ".copyHandle(0x" + ch.toString(16) + ")";
    });
    this.movedHandles.forEach((ch) => {
        str+= ".moveHandle(0x" + ch.toString(16) + ")";
    });
    this.inputObjectIds.forEach((ch) => {
        str+= ".inputObjectId(0x" + ch.toString(16) + ")";
    });
    if(this.objectDomainCommand) {
        switch(this.objectDomainCommand) {
        case 1:
            str+= ".toObject(" + this.objectId + ")";
            break;
        case 2:
            str+= ".closeObject(" + this.objectId + ")";
            break;
        default:
            throw new Error("unknown domain command");
        }
    }
    return str;
};

IPCMessage.prototype.assertOk = function () {
    if(!this.success) {
        this.show();
        throw new ResultCode(this.resultCode);
    } else {
        return this;
    }
};

IPCMessage.prototype.asResult = function () {
    if(this.success) {
        return new Result.Ok(this);
    } else {
        return new Result.Err(this);
    }
};

// calls cb if our result code == 0, err otherwise
// cb signature is (msg, moved, copied) => { ... }
// returns value returned from cb
IPCMessage.prototype.withHandles = function(cb, err) {
    try {
        if(this.success) {
            return cb(this, this.movedHandles, this.copiedHandles);
        } else {
            if(err) {
                return err(this, this.movedHandles, this.copiedHandles);
            } else {
                return this;
            }
        }
    } finally {
        var sender = this.sender;
        this.movedHandles.forEach((mh) => {
            sender.svcCloseHandle(mh);
        });
        this.copiedHandles.forEach((ch) => {
            sender.svcCloseHandle(ch);
        });
    }
};

IPCMessage.prototype.toString = function() {
    return "IPCMessage(" + this.cmdId + " = " + new ResultCode(this.resultCode).toString() + ")";
};

function IPCFailure(sc, sender, resultCode) {
    this.resultCode = resultCode;
    this.sc = sc;
    this.sender = sender;
}

IPCFailure.prototype.assertOk = function () {
    this.show();
    throw this.resultCode;
};

IPCFailure.prototype.asResult = function () {
    return new Result.Err(this);
};

IPCFailure.prototype.withHandles = function(ok, err) {
    if(err) {
        return err(this, [], []);
    } else {
        return this;
    }
};

IPCFailure.prototype.show = function () {
    utils.log("IPC Failure: " + this.resultCode.message + ", offending request shown below");
    new IPCMessage(this.sc, this.sender).unpack(this.sc.ipcBuf, this.objectDomainCommand != null).show();
    return this;
};

IPCFailure.prototype.toString = function () {
    return "IPCFailure(" + this.resultCode.toString() + ")";
};

IPCFailure.prototype.success = false;
IPCFailure.prototype.isFailure = true;

sploitMixin.ipcMsg = function (cmdId) {
    return new IPCMessage(this.sc, this, cmdId);
};

/*
  If no `cb` is passed, return a Result.
    Ok(u32 handle) if everything is okay
    Err(ResultCode) if `sm:` returned an unsuccessful result code
    Throw if `name` is not a string, no such service exists, or we fail to connect to `sm:`
  If `cb` is passed:
    Calls `cb` with the `u32 handle` if successful. If we fail to get a handle, throw.
    Returns value returned from `cb` and automatically closes handle after `cb` returns.
 */
sploitMixin.getService = function (name, cb) {
    if (typeof(name) !== "string") {
        throw new Error("cannot get service with non-string name");
    }
    
    /* We can only query services if we have smhax. */
    if (utils.smhax.get()) {
        if (!this.sc.hasService(name)) {
            throw new Error('no such service');
        }
    }

    if (this.smHandle === undefined) {
        this.smHandle = this.svcConnectToPort('sm:').assertOk();
        
        /* Without smhax we have to initialize sm. */
        if (!utils.smhax.get()) {
            this.ipcMsg(0).sendPid().datau64(0).sendTo(this.smHandle).assertOk();
        }
    }
    var lol = utils.str2u64(name);
    var r = this.ipcMsg(1).datau64(lol).sendTo(this.smHandle).asResult().map((response) => response.movedHandles[0]);
    if(cb === undefined) {
        return r;
    } else {
        var h = r.assertOk();
        try {
            return cb(h);
        } finally {
            this.svcCloseHandle(h);
        }
    }
};

sploitMixin.getServices = function(services, callback) {
    var serviceHandles = [];

    for (var si = 0; si < services.length; si++) {
        var service = this.getService(services[si]).assertOk();
        serviceHandles.push( service );
    }

    try {
        return callback.apply(undefined, serviceHandles);
    } finally {
        for (var shi = 0; si < serviceHandles.length; shi++) {
            this.svcCloseHandle(serviceHandles[shi]);
        }
    }
};

sploitMixin.registerService = function (name, maxSessions) {
    if (this.smHandle === undefined) {
        this.smHandle = this.svcConnectToPort('sm:').assertOk();
    }
    if (maxSessions === undefined) {
        maxSessions = 1000;
    }
    var lol = utils.str2u64(name);
    utils.dlog('Registering service ' + name);
    return this.ipcMsg(2).datau64(lol, [maxSessions, 0x20]).sendTo(this.smHandle).asResult().map((r) => r.movedHandles[0]);
};

sploitMixin.unregisterService = function (name) {
    if (this.smHandle === undefined) {
        this.smHandle = this.svcConnectToPort('sm:').assertOk();
    }
    var lol = utils.str2u64(name);
    return this.ipcMsg(3).datau64(lol).sendTo(this.smHandle).asResult();
};

sploitcore.prototype.hasService = function (name) {
    if (this.ipcServices[name] === undefined) {
        var r = this.registerService(name, 1000);
        if(r.isOk) {
            this.ipcServices[name] = false;
            this.unregisterService(name).assertOk();
        } else {
            this.ipcServices[name] = true;
        }
    }
    return this.ipcServices[name];
};

sploitMixin.getAutoHandle = function (name) {
    if (this.ipcHandles[name] === undefined) {
        if (name instanceof Function) {
            this.ipcHandles[name] = name();
        } else if (typeof(name) === "string") {
            this.ipcHandles[name] = this.getService(name).assertOk();
        } else {
            throw new Error("invalid auto handle type " + name);
        }
    }
    return this.ipcHandles[name];
};

sploitMixin.killAutoHandle = function (name) {
    if (name === undefined) {
        for (var name in this.ipcHandles) {
            this.killAutoHandle(name);
        }
        return;
    }

    if (this.ipcHandles[name] === undefined) { return; }

    this.svcCloseHandle(this.ipcHandles[name]).assertOk();
    delete this.ipcHandles[name];
};

module.exports = IPCMessage;
