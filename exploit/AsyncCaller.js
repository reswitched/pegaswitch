/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
/* global performance */
var utils = require('./utils');

class AsyncCaller {
	constructor (sc) {
		this.sc = sc;

		this.load_gadget = sc.gadget('020c41a9041442a9061c43a9082444a9');
		// this.ldr_x8 = sc.gadget('080540f900013fd6607e4092fd7b42a9f44f41a9')

		this.str_x0_x19 = sc.gadget('fd7b41a9600200f9f30742f8c0035fd6');
		this.ldr_x0 = sc.gadget('e00740f9fd7b41a9ff830091c0035fd6');
		this.br_x16 = sc.gadget('fd7bc1a800021fd6');
		this.ldr_x19 = sc.gadget('f31740f9fd7b43a9ff030191c0035fd6');
		this.exit_thread = sc.gadget('410100d4');
	}

	// timeout in milliseconds
	//	-1: no timeout
	call (func_ptr, args, timeout) {
		if (args.length >= 8) {
			throw new Error('too many arguments');
		}
		for (var i = 0; i < args.length; i++) {
			if (ArrayBuffer.isView(args[i])) {
				args[i] = args[i].buffer;
			}
			if (args[i] instanceof ArrayBuffer) {
				args[i] = this.sc.getArrayBufferAddr(args[i]);
			}
		}
		for (var i = args.length; i < 8; i++) {
			args[i] = [0, 0];
		}
		if (timeout === undefined) {
			timeout = 5000;
		}
		/*
	  ldr_x0:
	  0x7853e729a4		e00740f9	   ldr x0, [sp, 8] ; x0 = &(&exitThread-0x30)
	  0x7853e729a8		fd7b41a9	   ldp x29, x30, [sp, 0x10]
	  0x7853e729ac		ff830091	   add sp, sp, 0x20
	  0x7853e729b0		c0035fd6	   ret

	  load_gadget:
	  0x7853ed626c		020c41a9	   ldp x2, x3, [x0, 0x10]
	  0x7853ed6270		041442a9	   ldp x4, x5, [x0, 0x20]
	  0x7853ed6274		061c43a9	   ldp x6, x7, [x0, 0x30]
	  0x7853ed6278		082444a9	   ldp x8, x9, [x0, 0x40]
	  0x7853ed627c		0a2c45a9	   ldp x10, x11, [x0, 0x50]
	  -- snip --
	  0x7a9c63963c		104448a9	   ldp x16, x17, [x0, 0x80]
	  -- snip --
	  0x7853ed62a0		1c744ea9	   ldp x28, x29, [x0, 0xe0]
	  0x7853ed62a4		1e8040f9	   ldr x30, [x0, 0x100]
	  0x7853ed62a8		017c40f9	   ldr x1, [x0, 0xf8]
	  0x7853ed62ac		3f000091	   mov sp, x1
	  0x7853ed62b0		0004516d	   ldp d0, d1, [x0, 0x110]
	  -- snip --
	  0x7853ed62f0		1f0441fd	   ldr d31, [x0, 0x208]
	  0x7853ed62f4		000440a9	   ldp x0, x1, [x0]
	  0x7853ed62f8		c0035fd6	   ret

	  br_x16:
	  0x7a9c5ae6b0		fd7bc1a8	   ldp x29, x30, [sp], 0x10
	  0x7a9c5ae6b4		00021fd6	   br x16

	  FUNCTION EXECUTES HERE

	  ldr_x19:
	  0x7a9c22fea8		f31740f9	   ldr x19, [sp, 0x28]		 ; [0x28:4]=0x8e2e9c ; '('
	  0x7a9c22feac		fd7b43a9	   ldp x29, x30, [sp, 0x30]
	  0x7a9c22feb0		ff030191	   add sp, sp, 0x40
	  0x7a9c22feb4		c0035fd6	   ret

	  str_x0_x19:
	  0x7a9c303f4c		fd7b41a9	   ldp x29, x30, [sp, 0x10]
	  0x7a9c303f50		600200f9	   str x0, [x19]
	  0x7a9c303f54		f30742f8	   ldr x19, [sp], 0x20
	  0x7a9c303f58		c0035fd6	   ret

	  ldr_x0:
	  0x7853e729a4		e00740f9	   ldr x0, [sp, 8] ; x0 = magic return flag
	  0x7853e729a8		fd7b41a9	   ldp x29, x30, [sp, 0x10]
	  0x7853e729ac		ff830091	   add sp, sp, 0x20
	  0x7853e729b0		c0035fd6	   ret

	  str_x0_x19
	  0x7a9c303f4c		fd7b41a9	   ldp x29, x30, [sp, 0x10]
	  0x7a9c303f50		600200f9	   str x0, [x19] ; magic return flag
	  0x7a9c303f54		f30742f8	   ldr x19, [sp], 0x20
	  0x7a9c303f58		c0035fd6	   ret

	  exit_thread:
	  0x7853e855b4		410100d4	   svc 0xa		; ExitThread
	*/

		var load_gadget = this.load_gadget;
		// var ldr_x8 = this.ldr_x8
		var str_x0_x19 = this.str_x0_x19;
		var ldr_x0 = this.ldr_x0;
		var br_x16 = this.br_x16;
		var ldr_x19 = this.ldr_x19;
		var exit_thread = this.exit_thread;
		var sc = this.sc;

		return new Promise((resolve, reject) => {
			var magic_return_flag = [0, 0];
			while (magic_return_flag[0] === 0 && magic_return_flag[1] === 0) {
				magic_return_flag = [Math.floor(Math.random() * 0x1000), Math.floor(Math.random() * 0x1000)];
			}

			var load_area = sc.malloc(0x280);
			var sp = sc.malloc(0x300);
			var initial_sp = sp;
			var scratch = sc.malloc(0x20);
			sc.write8([0, 0], scratch, 0x00 >> 2); // return value
			sc.write8([0, 0], scratch, 0x10 >> 2); // magic return flag
			var return_value_addr = utils.add2(scratch, 0x00);
			var magic_return_flag_addr = utils.add2(scratch, 0x10);

			sc.write8(load_area, sp, 0x8 >> 2); // ldr x0, [sp, 8]
			sc.write8(load_gadget, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			sp = utils.add2(sp, 0x20); // add sp, sp, 0x20

			sc.write8(args[0], load_area, 0x000 >> 2);
			sc.write8(args[1], load_area, 0x008 >> 2);
			sc.write8(args[2], load_area, 0x010 >> 2);
			sc.write8(args[3], load_area, 0x018 >> 2);
			sc.write8(args[4], load_area, 0x020 >> 2);
			sc.write8(args[5], load_area, 0x028 >> 2);
			sc.write8(args[6], load_area, 0x030 >> 2);
			sc.write8(args[7], load_area, 0x038 >> 2);
			sc.write8(func_ptr, load_area, 0x080 >> 2); // x16
			sc.write8(sp, load_area, 0xf8 >> 2); // sp
			sc.write8(br_x16, load_area, 0x100 >> 2); // x30 (LR)

			sc.write8(ldr_x19, sp, 0x8 >> 2); // ldp x29, x30, [sp], 0x10
			sp = utils.add2(sp, 0x10);

			// br x16
			//	FUNCTION EXECUTES HERE

			// ldr_x19:
			sc.write8(return_value_addr, sp, 0x28 >> 2); // ldr x19, [sp, 0x28]
			sc.write8(str_x0_x19, sp, 0x38 >> 2); // ldp x29, x30, [sp, 0x30]
			sp = utils.add2(sp, 0x40); // add sp, sp, 0x40
			// ret

			// str_x0_19:
			sc.write8(ldr_x0, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			// str x0, [x19]
			sc.write8(magic_return_flag_addr, sp, 0x0 >> 2); // ldr x19, [sp], 0x20
			sp = utils.add2(sp, 0x20);
			// ret

			// ldr_x0:
			sc.write8(magic_return_flag, sp, 0x8 >> 2); // ldr x0, [sp, 8]
			sc.write8(str_x0_x19, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			sp = utils.add2(sp, 0x20); // add sp, sp, 0x20
			// ret

			// str_x0_19:
			sc.write8(exit_thread, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			// str x0, [x19]
			// ldr x19, [sp], 0x20
			sp = utils.add2(sp, 0x20);
			// ret

			// svcExitThread

			var prio = [58, 0];
			var handle = sc.svcCreateThread(ldr_x0, load_area, initial_sp, prio, 1).assertOk();
			sc.svcStartThread(handle).assertOk();

			var begin = performance.now();
			var wait = function () {
				var field = sc.read8(scratch, 0x10 >> 2);
				if (field[0] !== magic_return_flag[0] || field[1] !== magic_return_flag[1]) {
					if (timeout >= 0 && (performance.now() - begin) > timeout) {
						sc.svcCloseHandle(handle).assertOk();
						sc.free(load_area);
						sc.free(initial_sp);
						sc.free(scratch);
						reject(new Error('timed out'));
					} else {
						window.requestAnimationFrame(wait);
					}
				} else {
					sc.svcCloseHandle(handle).assertOk();
					sc.free(load_area);
					sc.free(initial_sp);
					sc.free(scratch);
					resolve(sc.read8(scratch, 0x00));
				}
			};
			window.requestAnimationFrame(wait);
		});
	}
}

module.exports = AsyncCaller;
