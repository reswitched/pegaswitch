var Result = require('./Result');
var ResultCode = require('./ResultCode');
var utils = require('./utils');

var svcMixin = {};
svcMixin.svcWithResult = function (id, args, dumpRegs) {
	var ret = this.svc(id, args, dumpRegs);
	if (ret[0] !== 0 || ret[1] !== 0) {
		return new Result.Err(new ResultCode(ret));
	} else {
		return Result.NullOk;
	}
};

/*
  Usages:
  svcCreateTransferMemory(size)
  svcCreateTransferMemory(arrayBuffer)
  svcCreateTransferMemory(address, size)
  svcCreateTransferMemory(arrayBuffer, permission)
  svcCreateTransferMemory(address, size, permission)
*/
svcMixin.svcCreateTransferMemory = function () {
	var address;
	var size;
	var permission = 0;
	switch (arguments.length) {
	case 0:
		throw new Error('expected at least one argument');
	case 1:
		if (Array.isArray(arguments[0]) || typeof (arguments[0]) === 'number') {
			size = arguments[0];
			break;
		}
		if (arguments[0] instanceof ArrayBuffer) {
			if (!this.isBrowser) {
				throw new Error("don't try to make transfer memory with ArrayBuffers if you're not the browser please");
			}
			address = this.getArrayBufferAddr(arguments[0]);
			size = [arguments[0].byteLength, 0];
			break;
		}
		throw new Error('invalid usage, single argument is expected to be a size, typed array, or ArrayBuffer');
	case 2:
		if (Array.isArray(arguments[0])) {
			address = arguments[0];
			size = arguments[1];
			break;
		}
		if (arguments[0] instanceof ArrayBuffer) {
			if (!this.isBrowser) {
				throw new Error("don't try to make transfer memory with ArrayBuffers if you're not the browser please");
			}
			address = this.getArrayBufferAddr(arguments[0]);
			size = arguments[0].byteLength;
			permission = arguments[1];
			break;
		}
		throw new Error('invalid usage, expected (address, size) or (arrayBuffer, permission)');
	case 3:
		address = arguments[0];
		size = arguments[1];
		permission = arguments[2];
		break;
	default:
		throw new Error('invalid usage');
	}
	if (address === undefined) {
		address = this.malloc(size);
	}

	address = utils.pad64(address);
	size = utils.pad64(size);
	permission = utils.pad64(permission);

	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x15, [handleBuffer, address, size, permission]).replaceValue(handleBuffer[0]);
};

/*
  Usages:
  svcCreateSharedMemory(size)
  svcCreateSharedMemory(size, permission)
  svcCreateSharedMemory(size, permission1, permission2)
*/
svcMixin.svcCreateSharedMemory = function (size, permission1, permission2) {
	if (permission1 === undefined) {
		permission1 = 3; // RW
	}
	if (permission2 === undefined) {
		permission2 = permission1;
	}

	if (typeof (size) === 'number') { size = [size, 0]; }
	if (typeof (permission1) === 'number') { permission1 = [permission1, 0]; }
	if (typeof (permission2) === 'number') { permission2 = [permission2, 0]; }

	if (!Array.isArray(size)) { throw new Error('invalid size type'); }
	if (!Array.isArray(permission1)) { throw new Error('invalid permission1 type'); }
	if (!Array.isArray(permission2)) { throw new Error('invalid permission2 type'); }

	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x50, [handleBuffer, size, permission1, permission2]).replaceValue(handleBuffer[0]);
};

/*
  Usages:
  svcGetThreadId()
  svcGetThreadId(tid)
*/
svcMixin.svcGetThreadId = function (tid) {
	if (tid === undefined) {
		tid = 0xffff8000;
	}

	if (typeof (tid) === 'number') { tid = [tid, 0]; }
	if (!Array.isArray(tid)) { throw new Error('invalid tid type'); }

	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x25, [handleBuffer, tid]).replaceValue([handleBuffer[0], handleBuffer[1]]);
};

/*
  Usages:
  svcMapSharedMemory(handle, size)
  svcMapSharedMemory(handle, size, perm)
  svcMapSharedMemory(handle, addr, size, perm)

  Returns:
  Mapped address
 */
svcMixin.svcMapSharedMemory = function (handle) {
	var size;
	var addr;
	var perm = 3;
	switch (arguments.length) {
	case 3:
		perm = arguments[2];
		// fallthrough
	case 2:
		size = arguments[1];
		addr = this.findUnmappedRegion(size);
		break;
	case 4:
		addr = arguments[1];
		size = arguments[2];
		perm = arguments[3];
		break;
	default:
		throw new Error('invalid usage');
	}

	return this.svcWithResult(0x13, [handle, addr, size, perm]).replaceValue(addr);
};

/*
  Usages:
  svcMapTransferMemory(handle, size)
  svcMapTransferMemory(handle, size, perm)
  svcMapTransferMemory(handle, addr, size, perm)

  Returns:
  Mapped address
 */
svcMixin.svcMapTransferMemory = function (handle) {
	var size;
	var addr;
	var perm = 3;
	switch (arguments.length) {
	case 3:
		perm = arguments[2];
		// fallthrough
	case 2:
		size = arguments[1];
		addr = this.findUnmappedRegion(size);
		break;
	case 4:
		addr = arguments[1];
		size = arguments[2];
		perm = arguments[3];
		break;
	default:
		throw new Error('invalid usage');
	}

	return this.svcWithResult(0x51, [handle, addr, size, perm]).replaceValue(addr);
};

svcMixin.svcUnmapTransferMemory = function (handle, addr, size) {
	return this.svcWithResult(0x52, [handle, addr, size]);
};

svcMixin.svcGetSystemTick = function () {
	var info = new Uint32Array(2);
	return this.svcWithResult(0x29, [info, 10, 0, [0xFFFFFFFF, 0xFFFFFFFF]]).replaceValue([info[0], info[1]]); // GetSystemTick
};

svcMixin.svcQueryMem = function (addr, raw) {
	if (arguments.length === 1) { raw = false; }

	var meminfo = new Uint32Array(12);
	var pageinfo = new Uint32Array(2);

	var memperms = ['NONE', 'R', 'W', 'RW', 'X', 'RX', 'WX', 'RWX'];
	var memstates = ['NONE', 'IO', 'NORMAL', 'CODE-STATIC', 'CODE', 'HEAP', 'SHARED-MEM', 'WEIRD-SHARED-MEM', 'MODULE-CODE-STATIC', 'MODULE-CODE', 'IPC-BUF-0', 'MEM-MAP', 'THREAD-LOCAL-STORAGE', 'TRANSFER-MEMORY-ISOLATED', 'TRANSFER-MEMORY', 'PROCESS-MEMORY', 'RESERVED', 'IPC-BUF-1', 'IPC-BUF-3', 'KERN-STACK'];
	return this.svcWithResult(0x6, [meminfo, pageinfo, addr]).map(() => {
		var ms = meminfo[4];
		if (!raw && ms < memstates.length) { ms = memstates[ms]; } else if (!raw) { ms = 'UNKNOWN'; }
		var mp = meminfo[6];
		if (!raw && mp < memperms.length) { mp = memperms[mp]; }
    
		return [[meminfo[0], meminfo[1]], [meminfo[2], meminfo[3]], ms, mp, [pageinfo[0], pageinfo[1]]];
	});
};

svcMixin.svcCloseHandle = function (handle) {
	return this.svcWithResult(0x16, [handle]);
};

svcMixin.svcConnectToPort = function (portName) {
	var handleBuffer = new Uint32Array(2);
	var ret = this.svcWithResult(0x1F, [handleBuffer, utils.str2ab(portName)]).replaceValue([handleBuffer[0], handleBuffer[1]]);
	return ret;
};

svcMixin.svcSendSyncRequestWithUserBuffer = function (addr, size, handle) {
	return this.svcWithResult(0x22, [addr, size, handle]);
};

svcMixin.svcCreateThread = function (entry, arg, stacktop, prio, processorId) {
	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x8, [handleBuffer, entry, arg, stacktop, prio, processorId]).replaceValue([handleBuffer[0], handleBuffer[1]]);
};

svcMixin.svcStartThread = function (handle) {
	return this.svcWithResult(0x9, [handle]);
};

svcMixin.svcAcceptSession = function (port) {
	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x41, [handleBuffer, port]).replaceValue(handleBuffer[0]);
};

svcMixin.svcReplyAndReceiveWithUserBuffer = function (buf, handles, reply, timeout) {
	var handleIdxBuffer = new Uint32Array(2);
	return this.svcWithResult(0x44, [handleIdxBuffer, buf, buf.byteLength, handles ? new Uint32Array(handles) : 0, handles ? handles.length : 0, reply, timeout]).replaceValue(handleIdxBuffer[0]);
};

svcMixin.svcWaitSynchronization = function (handles, timeout) {
	var handlesBuffer = new Uint32Array(handles);
	var handleIdxBuffer = new Uint32Array(1);
	return this.svcWithResult(0x18, [handleIdxBuffer, handlesBuffer, handlesBuffer.length, timeout]).replaceValue(handleIdxBuffer[0]);
}

module.exports = svcMixin;
