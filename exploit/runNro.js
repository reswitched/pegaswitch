/*
    requires spl MITM and ro!ease_nro_restriction = 0x1
*/

var utils = require("./utils")

module.exports = (res, args) => {
    if(!sc.sdb) {
        throw new Error("requires spl mitm. try `enable sdbcore`");
    }
    if(sc.version !== "3.0.0") {
        throw new Error("requires 3.0.0");
    }
    
    var nrr = new ArrayBuffer(0x1000);
    var nrru32 = new Uint32Array(nrr);
    nrru32[0] = 0x3052524E; // NRR0
    nrru32[(0x338 >> 2) + 0] = 0x1000; // Size
    nrru32[(0x340 >> 2) + 0] = 0x350; // Hash offset
    nrru32[(0x340 >> 2) + 1] = 0x1; // Hash count
    
    while(res.length & 0xFFF)
        res.push(0);
    var u8 = new Uint8Array(res);
    var u32 = new Uint32Array(u8.buffer);

    var nroSize = u32[0x18 >> 2];
    var bssSize = u32[0x38 >> 2];
    var mod0Offset = u32[1];
    var dynamicOffset = mod0Offset + u32[(mod0Offset >> 2) + 1];

    utils.log("dynamic offset: 0x" + dynamicOffset.toString(16));

    return crypto.subtle.digest("SHA-256", u8.buffer).then((hash) => {
        var nrrhashu8 = new Uint8Array(nrr, 0x350, 32);
        var hashu8 = new Uint8Array(hash);
        nrrhashu8.set(hashu8);
        
        return sc.getService("ldr:ro", (ldrro) => {
            var nrraddr = sc.getArrayBufferAddr(nrr);
            sc.ipcMsg(4).datau64(0).sendPid().copyHandle(0xffff8001).sendTo(ldrro).assertOk();
            sc.ipcMsg(2).datau64(0, nrraddr, nrr.byteLength).sendPid().sendTo(ldrro).show();
            
            var nrobase = sc.malloc(u8.length + bssSize + 0xfff);
            if(nrobase[0] & 0xFFF)
                nrobase[0] = ((nrobase[0] & 0xFFFFF000) + 0x1000) >>> 0;
            
            sc.memcpy(nrobase, u8, u8.byteLength);
            
            sc.svcNroBase = sc.ipcMsg(0).datau64(0, nrobase, nroSize, utils.add2(nrobase, nroSize), bssSize).sendPid().sendTo(ldrro).assertOk().data;

            sc.ipcMsg(3).datau64(0, nrraddr).sendPid().sendTo(ldrro).assertOk();
            
            utils.log('NRO loaded at ' + utils.paddr(sc.svcNroBase));

            if(args === undefined) {
                args = [];
            }
            var argAbs = args.map((arg) => utils.str2ab(arg));
            var argv = new Uint32Array(argAbs.length * 2);
            for(var i = 0; i < argAbs.length; i++) {
                var addr = sc.getArrayBufferAddr(argAbs[i]);
                argv[(i*2)+0] = addr[0];
                argv[(i*2)+1] = addr[1];
            }
            utils.hexdump("argv", argv);

            var argvAddr = sc.getArrayBufferAddr(argv);

            var magic = utils.parseAddr("007874635f656361");
            var appHeap = new ArrayBuffer(0x400000);
            var appHeapAddr = sc.getArrayBufferAddr(appHeap);

            var loaderConfig = new Uint32Array([
                3, // key (OverrideHeap)
                1, // flags ([RECOGNITION-MANDATORY])
                appHeapAddr[0], appHeapAddr[1], // value[0]
                appHeap.byteLength, 0, // value[1]

                5, // key (Argv)
                0, // flags
                argAbs.length, 0, // value[0]
                argvAddr[0], argvAddr[1], // value[1]

                8, // key (AppletWorkaround)
                1, // flags ([RECOGNITION-MANDATORY])
                0, 0, // value[0] (aruid)
                0, 0, // value[1] (ignored)
                
                0, // key (EndOfList)
                1, // flags ([RECOGNITION-MANDATORY])
                0, 0, 0, 0, // value[0], (ignored) value[1] (ignored)
            ]);
            
            utils.log("closing sm and jumping...");
            sc.svcCloseHandle(sc.smHandle).assertOk();
            sc.smHandle = undefined;
            var ret = sc.call(sc.svcNroBase, [loaderConfig]);
            utils.log("returned " + utils.paddr(ret));
            return ret;
        });
    }).catch((e) => {
        utils.log("error in then()");
        window.onerror(e.message, null, e.line, null, e);
    });
};
